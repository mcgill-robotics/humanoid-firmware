// Generated by gencpp from file custom_msgs/MoboError.msg
// DO NOT EDIT!

#ifndef CUSTOM_MSGS_MESSAGE_MOBOERROR_H
#define CUSTOM_MSGS_MESSAGE_MOBOERROR_H

#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>
#include <ros/serialization.h>
#include <ros/types.h>

#include <memory>
#include <string>
#include <vector>

namespace custom_msgs {
template <class ContainerAllocator>
struct MoboError_ {
  typedef MoboError_<ContainerAllocator> Type;

  MoboError_() : errorMsg(), value(0) {}
  MoboError_(const ContainerAllocator& _alloc) : errorMsg(_alloc), value(0) {
    (void)_alloc;
  }

  typedef std::basic_string<char, std::char_traits<char>,
                            typename std::allocator_traits<ContainerAllocator>::
                                template rebind_alloc<char>>
      _errorMsg_type;
  _errorMsg_type errorMsg;

  typedef int32_t _value_type;
  _value_type value;

  typedef boost::shared_ptr<::custom_msgs::MoboError_<ContainerAllocator>> Ptr;
  typedef boost::shared_ptr<::custom_msgs::MoboError_<ContainerAllocator> const>
      ConstPtr;

};  // struct MoboError_

typedef ::custom_msgs::MoboError_<std::allocator<void>> MoboError;

typedef boost::shared_ptr<::custom_msgs::MoboError> MoboErrorPtr;
typedef boost::shared_ptr<::custom_msgs::MoboError const> MoboErrorConstPtr;

// constants requiring out of line definition

template <typename ContainerAllocator>
std::ostream& operator<<(
    std::ostream& s, const ::custom_msgs::MoboError_<ContainerAllocator>& v) {
  ros::message_operations::Printer<
      ::custom_msgs::MoboError_<ContainerAllocator>>::stream(s, "", v);
  return s;
}

template <typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::custom_msgs::MoboError_<ContainerAllocator1>& lhs,
                const ::custom_msgs::MoboError_<ContainerAllocator2>& rhs) {
  return lhs.errorMsg == rhs.errorMsg && lhs.value == rhs.value;
}

template <typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::custom_msgs::MoboError_<ContainerAllocator1>& lhs,
                const ::custom_msgs::MoboError_<ContainerAllocator2>& rhs) {
  return !(lhs == rhs);
}

}  // namespace custom_msgs

namespace ros {
namespace message_traits {

template <class ContainerAllocator>
struct IsMessage<::custom_msgs::MoboError_<ContainerAllocator>> : TrueType {};

template <class ContainerAllocator>
struct IsMessage<::custom_msgs::MoboError_<ContainerAllocator> const>
    : TrueType {};

template <class ContainerAllocator>
struct IsFixedSize<::custom_msgs::MoboError_<ContainerAllocator>> : FalseType {
};

template <class ContainerAllocator>
struct IsFixedSize<::custom_msgs::MoboError_<ContainerAllocator> const>
    : FalseType {};

template <class ContainerAllocator>
struct HasHeader<::custom_msgs::MoboError_<ContainerAllocator>> : FalseType {};

template <class ContainerAllocator>
struct HasHeader<::custom_msgs::MoboError_<ContainerAllocator> const>
    : FalseType {};

template <class ContainerAllocator>
struct MD5Sum<::custom_msgs::MoboError_<ContainerAllocator>> {
  static const char* value() { return "a98e344e211c190d19b429d1c961056e"; }

  static const char* value(
      const ::custom_msgs::MoboError_<ContainerAllocator>&) {
    return value();
  }
  static const uint64_t static_value1 = 0xa98e344e211c190dULL;
  static const uint64_t static_value2 = 0x19b429d1c961056eULL;
};

template <class ContainerAllocator>
struct DataType<::custom_msgs::MoboError_<ContainerAllocator>> {
  static const char* value() { return "custom_msgs/MoboError"; }

  static const char* value(
      const ::custom_msgs::MoboError_<ContainerAllocator>&) {
    return value();
  }
};

template <class ContainerAllocator>
struct Definition<::custom_msgs::MoboError_<ContainerAllocator>> {
  static const char* value() {
    return "string errorMsg\n"
           "int32 value\n";
  }

  static const char* value(
      const ::custom_msgs::MoboError_<ContainerAllocator>&) {
    return value();
  }
};

}  // namespace message_traits
}  // namespace ros

namespace ros {
namespace serialization {

template <class ContainerAllocator>
struct Serializer<::custom_msgs::MoboError_<ContainerAllocator>> {
  template <typename Stream, typename T>
  inline static void allInOne(Stream& stream, T m) {
    stream.next(m.errorMsg);
    stream.next(m.value);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER
};  // struct MoboError_

}  // namespace serialization
}  // namespace ros

namespace ros {
namespace message_operations {

template <class ContainerAllocator>
struct Printer<::custom_msgs::MoboError_<ContainerAllocator>> {
  template <typename Stream>
  static void stream(Stream& s, const std::string& indent,
                     const ::custom_msgs::MoboError_<ContainerAllocator>& v) {
    s << indent << "errorMsg: ";
    Printer<
        std::basic_string<char, std::char_traits<char>,
                          typename std::allocator_traits<ContainerAllocator>::
                              template rebind_alloc<char>>>::stream(s,
                                                                    indent +
                                                                        "  ",
                                                                    v.errorMsg);
    s << indent << "value: ";
    Printer<int32_t>::stream(s, indent + "  ", v.value);
  }
};

}  // namespace message_operations
}  // namespace ros

#endif  // CUSTOM_MSGS_MESSAGE_MOBOERROR_H
